#!/usr/bin/env python
"""Submits coverage results to Coveralls.io through their API.

Usually you just need to run:
    coveralls_multi_ci submit

The following are CIs that are natively supported:
    Travis CI (including Pro)
    AppVeyor
    CircleCI
    Semaphore
    Jenkins
    Codeship
    Atlassian Bamboo

If you're using a CI not in the list above, you'll need to define these
environment variables:
    CI_NAME --
    CI_BUILD_NUMBER --
    CI_BUILD_URL --
    CI_BRANCH --
    CI_PULL_REQUEST -- TODO

Usage:
    coveralls_multi_ci submit [-c FILE] [-g DIR] [-q | -v]
    coveralls_multi_ci -h | --help
    coveralls_multi_ci -V | --version

Options:
    -c --coverage=FILE  Path to the coverage file generated by Coverage.
                        [default: .coverage]
    -g --git=DIR        Path to the root git repo directory.
                        [default: cwd]
    -h --help           Show this screen.
    -q --quiet          Print nothing to console.
    -v --verbose        Print debug information to console.
    -V --version        Show version.
"""

from datetime import datetime
import logging
import os
import sys
import signal

from coverage import coverage
from docopt import docopt
import pygit2

__author__ = '@Robpol86'
__license__ = 'MIT'
__version__ = '1.0.0'
API_URL = 'https://coveralls.io/api/v1/jobs'
CWD = os.path.abspath(os.path.expanduser(os.path.dirname(__file__)))
OPTIONS = docopt(__doc__) if __name__ == '__main__' else dict()


class Local(object):
    REPO_TOKEN = os.environ.get('COVERALLS_REPO_TOKEN')
    RUN_AT = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S +0000')
    SERVICE_NAME = 'coveralls_multi_ci'

    def __init__(self):
        self.source_files = coverage_report(os.path.join(CWD, OPTIONS.get('--coverage')))
        self.git = git_stats(CWD if OPTIONS.get('--git') == 'cwd' else OPTIONS.get('--git'))


class GenericCI(Local):
    SERVICE_NAME = os.environ.get('CI_NAME')
    SERVICE_NUMBER = os.environ.get('CI_BUILD_NUMBER')
    SERVICE_BUILD_URL = os.environ.get('CI_BUILD_URL')
    SERVICE_BRANCH = os.environ.get('CI_BRANCH')
    SERVICE_PULL_REQUEST = os.environ.get('CI_PULL_REQUEST')


class TravisCI(Local):
    """http://docs.travis-ci.com/user/ci-environment/#Environment-variables"""
    REPO_TOKEN = None
    SERVICE_NAME = 'travis-ci'
    SERVICE_JOB_ID = os.environ.get('TRAVIS_JOB_ID')


class AppVeyor(GenericCI):
    """http://www.appveyor.com/docs/environment-variables"""
    SERVICE_NAME = 'appveyor'


class CircleCI(GenericCI):
    """https://circleci.com/docs/environment-variables"""
    SERVICE_NAME = 'circle-ci'


class Semaphore(GenericCI):
    """https://semaphoreapp.com/docs/available-environment-variables.html"""
    SERVICE_NAME = 'semaphore'


class JenkinsCI(GenericCI):
    """https://wiki.jenkins-ci.org/display/JENKINS/Building+a+software+project"""
    SERVICE_NAME = 'jenkins-ci'


class Codeship(GenericCI):
    """https://codeship.io/documentation/continuous-integration/set-environment-variables/"""
    SERVICE_NAME = 'codeship'


class Bamboo(GenericCI):
    """https://confluence.atlassian.com/display/BAMBOO/Bamboo+variables"""
    SERVICE_NAME = 'bamboo'


def git_stats(repo_dir):
    """Generates a dictionary with metadata about the git repo.

    Attempts to resolve branch name if it's HEAD to a tag or branch name if the last commit is referenced by just one
    of either.

    Positional arguments:
    repo_dir -- root directory of the git repository.

    Returns:
    A nested dictionary whose structure matches the JSON data sent to the Coveralls API.
    """
    # Open handle to the repo and get basic data.
    try:
        repo = pygit2.Repository(repo_dir)
    except KeyError:
        logging.error('KeyError raised from pygit2, probably not in a git repo.')
        return dict()
    remotes = [dict(name=r.name.strip(), url=r.url.strip()) for r in repo.remotes]

    # Get branches. One commit may be referenced by many branches.
    branches = dict()  # dict(hex=[branch1, branch2, ...])
    for branch in (repo.lookup_branch(r) for r in repo.listall_branches()):
        branch_name = branch.branch_name
        for hex_ in (l.oid_new for l in branch.log() if l.message.startswith('commit')):
            if hex_ not in branches:
                branches[hex_] = set()
            branches[hex_].add(branch_name)

    # Get tags. One commit may be referenced by many tags.
    tags = dict()  # dict(hex=[tag1, tag2, ...])
    for tag in (repo.lookup_reference(x) for x in repo.listall_references() if x.startswith('refs/tags')):
        tag_name = tag.shorthand
        tag_or_commit = repo[tag.target.hex]
        hex_ = tag_or_commit.hex if tag_or_commit.type == pygit2.GIT_OBJ_COMMIT else repo[tag_or_commit.target].hex
        if hex_ not in tags:
            tags[hex_] = set()
        tags[hex_].add(tag_name)

    # Determine last commit.
    head_commit = repo.head.peel()
    if repo.head_is_detached and head_commit.hex in tags and len(tags[head_commit.hex]) == 1:
        branch = next(iter(tags[head_commit.hex]))
    elif repo.head_is_detached and head_commit.hex in branches and len(branches[head_commit.hex]) == 1:
        branch = next(iter(branches[head_commit.hex]))
    else:
        branch = repo.head.shorthand

    # Get metadata.
    head = dict(
        id=head_commit.hex,
        author_name=head_commit.author.name,
        author_email=head_commit.author.email,
        committer_name=head_commit.committer.name,
        committer_email=head_commit.committer.email,
        message=head_commit.message.strip(),
    )

    return dict(head=head, branch=branch, remotes=remotes)


def coverage_report(coverage_file):
    """Parse coverage file created before this script was executed.

    Looks like the author of Coverage doesn't want us subclassing his classes.
    http://nedbatchelder.com/blog/201409/how_should_i_distribute_coveragepy_alphas.html

    Positional arguments:
    coverage_file -- file path to the coverage file.

    Returns:
    List of dicts, each dict is one file and each dict holds API compatible coverage data.
    """
    source_files = list()
    logging.debug('Loading coverage file: ' + coverage_file)
    cov = coverage(data_file=coverage_file)
    cov.load()

    for file_path in cov.data.measured_files():
        logging.debug('Found coverage for: ' + file_path)
        with open(file_path, 'rU') as f:
            source_code = f.read(104857600)  # read up to 100 MiB.
            f.seek(0)
            file_coverage = [None for _ in f]  # List of Nones, same length as the number of lines in the file.
        analysis = cov.analysis(file_path)[1:-1]

        for i in analysis[0]:
            file_coverage[i - 1] = 1
        for i in analysis[1]:
            file_coverage[i - 1] = 0

        source_files.append(dict(name=file_path.replace(CWD, ''), source=source_code, coverage=file_coverage))

    return source_files


def select_ci():
    """Instantiates the appropriate class and returns the instance."""
    if 'CI' in os.environ and 'TRAVIS' in os.environ:
        instance = TravisCI()
    elif 'CI' in os.environ and 'APPVEYOR' in os.environ:
        instance = AppVeyor()
    elif 'CI' in os.environ and 'CIRCLECI' in os.environ:
        instance = CircleCI()
    elif 'CI' in os.environ and 'SEMAPHORE' in os.environ:
        instance = Semaphore()
    elif 'JENKINS_URL' in os.environ:
        instance = JenkinsCI()
    elif 'CI' in os.environ and os.environ.get('CI_NAME') == 'codeship':
        instance = Codeship()
    elif 'bamboo.buildNumber' in os.environ:
        instance = Bamboo()
    else:
        logging.debug('Did not detect an officially supported CI. Trying the generic class.')
        if 'CI_NAME' in os.environ:
            instance = GenericCI()
        else:
            logging.warning('Resorting to Local class. Environment variable "CI_NAME" not defined.')
            instance = Local()
    return instance


def post_to_api(instance):
    pass


def main():
    # Instantiate class relevant to the current CI. Also collects metadata about git and code coverage.
    logging.debug('Selecting CI class.')
    instance = select_ci()
    logging.info('Using {0}; Coverage of {0} file(s); {0} branch/tag.'.format(instance.__class__.__name__,
                                                                              len(instance.source_files),
                                                                              instance.git['branch']))

    # Ok now we just submit it to the API. That's it.
    logging.info('POSTing to: {0}'.format(API_URL))
    post_to_api(instance)
    logging.debug('Done.')


def setup_logging():
    """Called when __name__ == '__main__' below. Sets up logging library.

    If --quiet was used, disables all logging, which is the only way this script writes to the console.

    Otherwise, all CRITICAL, ERROR, and WARNING messages go to stderr, while INFO and DEBUG messages go to stdout. If
    --verbose was used, all levels are enabled. If --verbose was not used, DEBUG messages will be silenced (done at the
    root logger level).
    """
    if OPTIONS.get('--quiet'):
        logging.disable(logging.CRITICAL)
        return
    fmt = '%(asctime)-15s %(levelname)-8s %(funcName)-13s %(message)s' if OPTIONS.get('--verbose') else '%(message)s'

    class InfoFilter(logging.Filter):
        """From http://stackoverflow.com/questions/16061641/python-logging-split-between-stdout-and-stderr"""
        def filter(self, rec):
            return rec.levelno in (logging.DEBUG, logging.INFO)

    handler_stdout = logging.StreamHandler(sys.stdout)
    handler_stdout.setFormatter(logging.Formatter(fmt))
    handler_stdout.setLevel(logging.DEBUG)
    handler_stdout.addFilter(InfoFilter())

    handler_stderr = logging.StreamHandler(sys.stderr)
    handler_stderr.setFormatter(logging.Formatter(fmt))
    handler_stderr.setLevel(logging.WARNING)

    root_logger = logging.getLogger()
    root_logger.setLevel(logging.DEBUG if OPTIONS.get('--verbose') else logging.INFO)
    root_logger.addHandler(handler_stdout)
    root_logger.addHandler(handler_stderr)

    logging.debug('coveralls_multi_ci {0}'.format(__version__))
    logging.debug('CWD: {0}'.format(CWD))
    logging.debug('OPTIONS values: \n{0}'.format(OPTIONS))

if __name__ == '__main__':
    signal.signal(signal.SIGINT, lambda *_: sys.exit(0))  # Properly handle Control+C
    setup_logging()
    if OPTIONS.get('--version'):
        logging.info('coveralls_multi_ci {0}'.format(__version__))
        sys.exit(0)
    main()
